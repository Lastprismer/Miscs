# KMP模式匹配算法

## 引入
### Brute Force*（BF算法，暴力匹配）

原理：从主串头开始，依次选取与模拟串长度相同的字串，逐个字符匹配；如果匹配失败，则检索下一个字串。
假设主串长m，字串长n：

<table style="text-align: center;">
<tr>
    <th>时间复杂度</th>
    <th><small>匹配成功</small></th>
    <th><small>匹配失败</small></th>
</tr>
<tr>
    <th><small>最优</small></th>
    <td>O(m)
    <td>O(n-m+1)
</tr>
<tr>
    <th><small>最差</small></th>
    <td>O((n-m+1)*m) ~ O(mn)</td>
    <td>O((n-m+1)*m) ~ O(mn)</td>
</tr>
</table>

成功最优：第一个模拟串就是子串：abcde与abc
失败最优：每一个模拟串，匹配到第一位，就和子串不同：abcdefg与jkl
失败最差：每次都匹配完，匹配到最后一个才确定：00000001和002
成功最差：每次都匹配完，匹配到最后一个才成功：00000001和001



### 关于优化的猜想
**KMP的目标：** 略去重复的判断

具体描述：设 $i$ 记录每次匹配位置在主串上的下标； $j$ 每次匹配位置在子串上的下标。
在bf算法中，每次匹配且未结束时，匹配成功时 $i=i+1，j=j+1$ ，匹配失败时 $i$ 回溯， $j$ 回到子串开头: $i=i-j+2，j=1$

问题：**回溯有必要吗？**
为描述方便，定义“状态”：描述形如 $i_xj_y$
意思是：$i=x，j=y$
单写 $i_x$ 和 $j_y$表示主串x位和子串y位

#### $i$ 的回溯

主串：abcdefghi……
子串：abcdefi

在第一轮匹配中，从 $i_0j_0$ 到 $i_5j_5$ ，子串与主串都相同；到了 $i_6j_6$ 后，匹配失败，状态转为 $i_1j_0$

可以发现，子串第0位 a 与之后的 bcdef 都不同，而子串的第1位到第5位 bcdef 相同，所以 $i_1j_0$ 必为false（ $i_1j_1=true\ \And j_0 \not ={j_1}$ ），之后同理，因为已经判断了 $i_6j_6$，所以 $i_6j_1$ 为false。

结论： $i_6j_6$ 后可直接转换到 $i_6j_0$

#### $j$ 的回溯

主串：abcababc……
子串：abcabx

第一轮：从 $i_0j_0$ 到 $i_4j_4$ 匹配，$i_5j_5$ 跳出
第二轮：依照上文经验：转换到 $i_3j_0$

分析：此时 $i_3j_0$ 是最优的选择吗？
此时，$i_3(a)=j_0(a)，i_4(b)=j_1(b)$，两者由 $j_0=i_0=i_3、j_1=i_1=i_4$推出

结论：$i_4j_4$ 后可直接转换到 $i_5j_2$

**结论：i、j的某些回溯都是没有必要的**



## 前缀函数算法
### 前缀函数定义
目的：寻找一个串中最长相等前后缀的长度
例如：ababa：前缀 <u>aba</u>ba，后缀 ab<u>aba</u>，长度为3

计算 $\pi$ 数组：
1. 如果子串 $s[0:i]$ 有一对相等的真前缀与真后缀：$s[0:k-1]$ 和 $s[i-k+1:i]$，那么 $\pi[i]$ 就是这个相等的真前缀（或者真后缀）的长度，也就是 $\pi[i] = k$；
2. 如果不止有一对相等的，那么 $\pi[i]$ 就是其中最长的那一对的长度；
3. 如果没有相等的，那么 $\pi[i] = 0$。
* 注：`string::substr(i, j)`为从 $i$ 开始取 $j$ 个字符

例子：
串：abcabx
$\pi[j]=\{0,0,0,1,2,0\}$
串：ababaaaba
$\pi[j]=\{0,0,1,2,3,1,1,2,3\}$




### 前缀函数计算

已知信息：
```c++
string s, int length = s.length(), pi[0] = 0
```
#### 朴素方法

* 从 $i = 1\rightarrow length$ 计算前缀函数$\pi[i]$的值
* 为了计算当前的前缀函数值 $\pi[i]$，我们令变量 $j$ 从可能的最大的真前缀长度 $i$ 开始尝试。
* 如果当前长度下真前缀和真后缀相等，则此时长度为 $j$，否则令 $j$ 自减 $1$，继续匹配，直到 $j=0$。
如果 $j=0$ 并且仍没有任何一次匹配，则令 $\pi[i]=0$。
```c++
void get_pi(string s, int* pi)
{
    int n = s.length();
    pi[0] = 0;
    for (int i = 1; i < n; i++)
    {
        pi[i] = 0;
        for (int j = i; j >= 0; j--)
        {
            if (s.substr(0, j) == s.substr(i - j + 1, j))
            {
                pi[i] = j;
                break;
            }
        }
    }
}
```
时间复杂度：$O(n^3)$，这太坏了



#### 优化

**前缀函数的性质**

1. $\pi[i+1] \leqslant \pi[i]+1$，当且仅当 $s[\pi[i]]=s[i+1]$ 时有 $\pi[i+1]=\pi[i]+1$
2. 令 $j$ 为 $s[0:i]$ 次长的相同前后缀的长度，则 $j=\pi(\pi[i]−1)$

推导：
1. 不等式关系易得：当需要求最长共同前后缀的串的末尾右移1时，共同前后缀的长度最多 $+1$；由定义知 $s[0:\pi[i]-1]=s[i-\pi[i]+1:i]$，若等号成立，只需 $s[\pi[i]]=s[i+1]$ 即可联立推出 $s[0:\pi[i+1]-1]=s[(i+1)-\pi[i+1]+1:i+1]$
$$
\underbrace {\overbrace{s_0\ s_1\ s_2}^{\pi[i]=3}\ s_3}_{\pi[i+1]=4}\ ...\ \underbrace{\overbrace{s_{i-2} \ s_{i-1} \ s_{i}}^{\pi[i]=3}\ s_{i+1}}_{\pi[i+1]=4}\ s_{i+2}\ ...
$$
2. 考虑 $s[\pi[i]]\not =s[i+1]$ 的情况，该如何计算 $\pi[i+1]$？
希望找到 $j$ 满足：对于子串 $s[0:i+1]$，$j$ 仅次于 $\pi[i]+1$，使得 $s[0:j-1]=s[i+1-j:i]$

$$
\overbrace{\underbrace{s_0\ s_1}_j\ \underbrace{s_2\ s_3}_j}^{\pi[i]}\ ...\ {\overbrace{s_{i-3}\ s_{i-2}\ \underbrace{s_{i-1}\ s_i}_{j}}^{\pi[i]}\ s_{i+1}}\ s_{i+2}\ ...\\
    \phantom{s_0\ s_1\ s_2}\underbrace{\phantom{\ s_3\ ...\ s_{i-3}\ s_{i-2}\ s_{i-1}}}_{前后相同}\phantom{\ s_i\ s_{i+1}\ s_{i+2}\ ...}
$$
如果我们找到了这样的长度 $j$，那么仅需要再次比较 $s[i+1]$ 和 $s[j]$。如果它们相等，那么就有 $\pi[i+1]=j+1$。否则，我们需要找到子串 $s[0:i]$ 仅次于 $j$ 的第二长度 $j_2$，使得前缀性质得以保持，如此反复，直到 $j=0$ 时，如果 $s[i+1]\not =s[j]$，则 $\pi[i+1]=0$。

观察上图可以发现，因为 $s[0:\pi[i]-1]=s[i-\pi[i]+1:i]$，所以对于 $s[0:i]$ 的第二长度 $j$，有这样的性质：
$$
s[0:j-1]=s[i-j+1:i]=s[\pi[i]-j:\pi[i]-1] \\
(=s[i-\pi[i]+1:i-\pi[i]+j])
$$

也就是说 $j$ 等价于子串 $s[0:\pi[i]-1]$ 的前缀函数值，即 $j=\pi[\pi[i]-1]$。同理，次于 $j$ 的第二长度等价于 $s[j-1]$ 的前缀函数值，$j^{(2)}=\pi[j-1]$

显然我们可以得到一个关于 $j$ 的状态转移方程：$j^{(n)}=\pi[j^{(n-1)}-1]$，$j^{(n)}$ 为第 $n$ 大的相同前后缀长度。

代码：
```c++
void get_pi(string s, int* pi)
{
    int n = s.length();
    pi[0] = 0;
    for (int i = 1; i < n; i++)
    {
        int j = pi[i - 1];
        while (j > 0 && s[i] != s[j])
            j = pi[j - 1];
        if (s[i] == s[j])
            j++;
        pi[i] = j; // j是最长相同前后缀的长度：s[0:j-1] = s[i-j+1:i] = s[pi[i-1]-j:pi[i-1]-1]
    }
    return;
}
```
时间复杂度：甚至只有 $O(n)$，离大谱



## KMP算法

### 数学证明

设主串为 $s_0s_1s_2...s_{m-2}s_{m-1}$，长度为 $m$；模式串为 $t_0t_1t_2...t_{n-2}t_{n-1}$，长度为 $n (n<m)$.

假设存在整数 $i,j$，使得：
$$
s[i:i+j-1]=t[0:j-1]\small \text{（}j=0\ \text{在后面单独分出来了）}
$$
即：模式串的某段和主串的某段匹配：匹配的**首位**对应主串下标为 $i$ 的位置；**已经匹配的**匹配串长度为 $j$，这次匹配失败了。现在的目标是分析：
1. 下一次匹配，主串指针有没有必要回溯
2. 下一次匹配，模式串指针应该指向什么位置
$$
s_0\ s_1\ ...\ s_{i-1}\ s_i\ s_{i+1}\ s_{i+2}\ ...\ s_{i+j-2}\ s_{i+j-1}\ s_{i+j}\ \dots\ s_{m-2}\ s_{m-1}\\
\phantom{s_0\ s_1\ ...\ \ s_{i-1}}\ t_0\ \ \ t_1\ \ \ t_2\ \ \dots\ \ \ t_{j-2}\ \ \ \ t_{j-1}\ \ \ \ t_{j}\ \ \ \
\phantom{\ ...\ s_{m-2}\ s_{m-1}}\\
\phantom{s_0\ s_1\ ...\ \ s_{i-1}\ t_0\ \ \ \ \ \ \ \ \ \ \ \ \ t_1\ \ \ t_2\ \ \dots\ \ \ t_{j-2}t_{j-1}}\ \ \ \ \ \ \ \ \ \uparrow{\small\text{此处匹配失败} }
\phantom{\ ...\ s_{m-2}\ s_{m-1}}\\
$$


依照 $j$ 的取值分类讨论。先给出结论：

* $j=0$，模式串第一个就寄了
    非常简单，模式串 $0$ 号位与主串下一位比较：证明显然。
    
* $j\geqslant1$，去计算模式串的 $\pi[j-1]$，即 $t_{j-1}$ 的前缀函数值，设$k=\pi[j-1]$。下一步需要：**模式串 $\pi[j-1]$ 号位与主串 *当前* 位比较**。

    对 $k$ 分类讨论：

    * $k\geqslant 0$，即有公共前后缀。进行如下操作：（非常自然的结论，也是前缀函数的必要条件）

    $$
    t[0:k-1]=t[j-k:j-1]
    $$
    
    
    则立即得到：（两个串取匹配的部分）
    $$
    \left\{
    \begin{array}{lcl}
    s[i:i+k-1]=t[0:k-1]\\
    s[i+j-k:i+j-1]=t[j-k:j-1]
    \end{array}\right. 
    $$
    
    
    联立可得：（主串后半截和匹配串前半截是一样的）
    $$
    t[0:k-1]=s[i+j-k:i+j-1]
    $$
    那此时把匹配串的前半截和主串后半截对齐，那必能对齐（废话），而且省去了主串第一位处在 $s[i+k:i+j-k-1]$ 之间的比较。
    **主串当前位是什么？** 是 $s[i+j]$，匹配失败。
    **模式串当前位应该选哪个？** 让公共前后缀的前缀的后面第一个位置：$t[k]$ 和 $s[i+j]$ 比较。
    那就是 $t[\pi[j-1]]与s[i+j]$ 比较
    
    举个例子：
    主串：$\ \ \ abcabnabcabx$
    模式串：$abcabx$
    设它们在 $s[5]=n,\ t[5]=x$ 处匹配失败
    计算 $\pi[4]=2$（公共前后缀：$ab$），则下一次比较的位置是 $s[5]=n$ 不变，$t[\pi[4]]=t[2]=c$
    这次显然依然失败，计算 $\pi[1]=0$，再下一次比较的位置是：$s[6]=a,t[0]=a$：
    $$
    abcab\textcolor{red}nabcabx\\
    abcab\textcolor{red}x\phantom{abcabx}\\
    \downarrow\\
    abcab\textcolor{red}nabcabx\\
    \phantom{abc}ab\textcolor{red}cabx\phantom{abx} \\
    \downarrow\\
    abcabn\textcolor{red}abcabx\\
    \phantom{abcabn}\textcolor{red}abcabx
    $$
    
    
    很明显，实际上就是把串 $abcab$ 的最长前缀拉到了后缀的位置上，这样能省去不少比较次数。
    
    由证明过程可知，$k$ 是**最长的**公共前后缀长度，所以不存在“忽略了某些，以相同方法判断，可被略过的情况”（略去的比较一定会在匹配这个前缀的时候就失败，否则这个前缀就不是**最长的**）



* $k=0$，即没有公共前后缀（此时的匹配串首位不等于末位，或者 $j=1$），显然应该且只能把 $j$ 回溯至模拟串开头。

* **主串有没有必要回溯？**

   没有公共前后缀，所以不存在 “此时，在主串的已匹配部分中取一点为模式串起点，实现后面的匹配” 的情况（**如果成立，则已匹配部分的后缀一定得有一块与前缀相同，但是没有**）。**不用回溯。**

  

  **模式串当前位应该选哪个？** 首位，$t[0]$。
  那就是 $t[\pi[j-1]]=t[0]与s[i+j]$ 比较

得到两个问题的答案：
1. **下一次匹配，主串指针有没有必要回溯**
**<font color="red">永不回溯</font>**
* 如果 $j=0$，那么去匹配主串失败处的下一个字符
* 如果 $j>0$，下一次匹配的仍然是主串失败处的那个字符
2. **下一次匹配，模式串指针应该指向什么位置**
* 如果 $j=0$，回溯到模式串开头
* 如果 $j>0$，计算 $\pi[j-1]$，回溯到 $t[\pi[j-1]]$ 处。

### 具体代码
```c++
void get_next(string t, int* next) // 对pi数组稍作改动
{
    int n = t.length();
    next[0] = 0;
    for (int i = 1; i < n; i++)
    {
        int j = next[i - 1];
        while (j > 0 && t[i] != t[j])
            j = next[j - 1];
        if (t[i] == t[j])
            j++;
        next[i] = j; // j是最长相同前后缀的长度：t[0:j-1] = t[i-j+1:i] = t[next[i-1]-j:next[i-1]-1]
    }
    next[0] = -1; // 首位设置成-1，标记特殊变化——主串为下一个字符，模式串为第一个字符
    return;
}

int kmp(string s, string t)
{
    int n = s.length();
    int m = t.length();
    int* next = new int[m];
    get_next(t, next);
    int i = 0, j = 0;
    while (i < n && j < m)
    {
        if (j == -1 || s[i] == t[j])
        {
            i++;
            j++;
        } // j为-1时，j++也就是模式串开头
        else
            j = next[j];
    }
    delete[] next;
    return j == m ? i - j : -1;
}
```
